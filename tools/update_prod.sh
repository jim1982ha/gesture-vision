#!/bin/bash
# FILE: tools/update_prod.sh
# Interactive script. Handles server deployment and optionally prepares APK assets.

# Navigate to the project root (parent directory of this script)
cd "$(dirname "$0")/.." || exit 1

# --- Configuration ---
# FIX: Point to the correct file locations inside the config/ directory
ENV_FILE="config/.env.prod"
EXAMPLE_ENV_FILE="config/.env.prod.example"
DOCKER_COMPOSE_FILE="docker-compose.yaml"
PROJECT_NAME="gesturevision_prod"

DOCKER_COMPOSE_CMD=""
if docker compose version &> /dev/null; then
    DOCKER_COMPOSE_CMD="docker compose"
elif command -v docker-compose &> /dev/null; then
    echo "INFO: Using 'docker-compose' (V1). Consider upgrading to Docker Compose V2 for 'docker compose'."
    DOCKER_COMPOSE_CMD="docker-compose"
else
    echo "ERROR: Neither 'docker compose' (V2) nor 'docker-compose' (V1) found. Aborting." >&2
    exit 1
fi

declare -A ENV_VARS_TO_REVIEW=(
    ["APP_EXTERNAL_URL"]="Req:Full HTTPS URL (e.g., https://gesture.mydomain.com)"
    ["NPM_NETWORK_NAME"]="Req:Docker network name used by NPM"
    ["MTX_ICE_HOST"]="Req:Externally accessible IP of this Docker host (for WebRTC)"
    ["MTX_PROD_WEBRTC_PORT"]="Opt:Host port if direct WHEP access needed (exposed from container)"
    ["MTX_PROD_WEBRTC_PORT_INTERNAL"]="Req:Internal WHEP port for MediaMTX (e.g., 8888, container listens here)"
    ["MTX_PROD_ICE_UDP_PORT"]="Opt:Host UDP port for WebRTC ICE (exposed from container)"
    ["MTX_PROD_ICE_UDP_PORT_INTERNAL"]="Req:Internal UDP port for MediaMTX ICE (e.g., 8189, container listens here)"
    ["MTX_PROD_RTMP_PORT"]="Opt:Host port if direct RTMP access needed (exposed from container)"
    ["MTX_PROD_RTMP_PORT_INTERNAL"]="Opt:Internal RTMP port for MediaMTX (e.g., 1935, container listens here)"
    ["MTX_PROD_RTSP_PORT"]="Opt:Host port if direct RTSP access needed (exposed from container)"
    ["MTX_PROD_RTSP_PORT_INTERNAL"]="Opt:Internal RTSP port for MediaMTX (e.g., 8554, container listens here)"
    ["MTX_PROD_LOGLEVEL"]="Opt:MediaMTX log level (info, debug, warn, error)"
    ["MTX_PROD_HLS_ADDRESS"]="Opt:MediaMTX HLS Address (e.g., :8887 or blank to disable)"
    ["MTX_API"]="Req:Enable MediaMTX API? (yes/no, default: yes)"
    ["MTX_APIADDRESS_INTERNAL"]="Req:MediaMTX API Listen Address (e.g., 0.0.0.0:9997 or :9997)"
    ["BACKEND_API_PORT_INTERNAL"]="Req:Internal port for Backend API (e.g., 9001, Nginx proxies to this)"
    ["VITE_PROD_HA_DEFAULT_URL"]="Opt:Default Home Assistant URL for UI (used at build time)"
    ["VITE_PROD_HA_DEFAULT_TOKEN"]="Opt:Default Home Assistant Token for UI (used at build time, masked)"
)

# --- Helper Functions ---
get_env_var() {
    local var_name="$1"; local env_file="$2";
    if [ ! -f "$env_file" ]; then echo ""; return; fi
    local line=$(grep -E "^\s*${var_name}\s*=" "$env_file" | grep -v '^\s*#' | tail -n 1)
    if [ -n "$line" ]; then
        local value=$(echo "$line" | sed -e "s/^[^=]*=//");
        value=$(echo "$value" | sed -e "s/^[[:space:]]*//" -e "s/[[:space:]]*$//");
        if [[ "$value" == \"*\" && "$value" == *\" ]]; then value=$(echo "$value" | sed -e 's/^"//' -e 's/"$//');
        elif [[ "$value" == \'*\' && "$value" == *\' ]]; then value=$(echo "$value" | sed -e "s/^'//" -e "s/'$//"); fi;
        echo "$value";
    else echo ""; fi
}

save_config_to_env() {
    local target_file="$1"; declare -n config_to_save=$2; local source_file_for_structure="$3";
    echo "Saving configuration to '$target_file'..."
    if [ -f "$target_file" ]; then cp "$target_file" "${target_file}.bak"; echo "Backup: ${target_file}.bak"; fi
    local temp_output_file="${target_file}.tmp"
    echo "# Config generated by script on $(date)" > "$temp_output_file"; echo "" >> "$temp_output_file"
    declare -A processed_keys_output
    local all_managed_keys=( "PROD_IMAGE_NAME" "${!ENV_VARS_TO_REVIEW[@]}" );
    mapfile -t unique_managed_keys < <(printf "%s\n" "${all_managed_keys[@]}" | sort -u)
    for key in "${unique_managed_keys[@]}"; do if [[ ! -v config_to_save["$key"] ]]; then config_to_save["$key"]=""; fi; done
    if [ -f "$source_file_for_structure" ]; then
        while IFS= read -r line || [[ -n "$line" ]]; do
            if [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*= ]]; then
                key="${BASH_REMATCH[1]}";
                if [[ -v config_to_save["$key"] ]]; then
                     local value_to_write="${config_to_save["$key"]}"
                     if [[ "$value_to_write" == *" "* ]]; then echo "$key=\"$value_to_write\"" >> "$temp_output_file";
                     else echo "$key=$value_to_write" >> "$temp_output_file"; fi
                     processed_keys_output["$key"]=1
                 else echo "$line" >> "$temp_output_file"; fi
            else echo "$line" >> "$temp_output_file"; fi
        done < "$source_file_for_structure"
    fi
    for key in "${unique_managed_keys[@]}"; do
         if [[ ! -v processed_keys_output["$key"] ]]; then
             local value_to_write="${config_to_save["$key"]}"
             if [[ "$value_to_write" == *" "* ]]; then echo "$key=\"$value_to_write\"" >> "$temp_output_file";
             else echo "$key=$value_to_write" >> "$temp_output_file"; fi;
         fi
    done
    mv "$temp_output_file" "$target_file"; echo "Successfully saved to '$target_file'."
}

display_help() {
    local script_name; script_name=$(basename "$0");
    echo "Usage: ./tools/${script_name} [options]";
    echo "Options:";
    echo " -h, --help          Display this help message and exit."
    echo " -y, --yes           Bypass all interactive prompts for server deployment."
    echo " --build             Force server image build strategy."
    echo " --run-only          Force using existing server image strategy (skip build)."
    echo " --no-cache          When building, build without using Docker cache."
    echo " --tag <image:tag>   Specify the server image tag to build or run."
    echo " --detached <true|false> Force detached or attached mode for server deployment."
    echo " --apk               Perform server deployment (if not skipped) AND then prepare APK assets."
    echo " --apk-only          ONLY prepare APK assets (skip all server deployment steps)."
    echo "Example (Deploy server & prep APK): ./tools/${script_name} --build --tag myimage:v1 --apk"
    echo "Example (Only prep APK assets): ./tools/${script_name} --apk-only"
}

confirm_action() {
    local prompt_message="$1"
    local default_choice="${2:-Y}"
    local choice
    read -r -p "$prompt_message [${default_choice}]: " choice
    choice=${choice:-$default_choice}
    [[ "$choice" =~ ^[Yy]$ ]]
}

# --- Argument Parsing ---
BYPASS_SERVER_INTERACTIVE=false
FORCE_SERVER_BUILD="ask"
FORCE_SERVER_DETACHED="ask"
SPECIFIED_SERVER_TAG=""
DO_APK_PREP=false
APK_ONLY_MODE=false
NO_CACHE_BUILD=false

while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        -h|--help) display_help; exit 0 ;;
        -y|--yes) BYPASS_SERVER_INTERACTIVE=true; shift ;;
        --build) FORCE_SERVER_BUILD="yes"; shift ;;
        --run-only) FORCE_SERVER_BUILD="no"; shift ;;
        --no-cache) NO_CACHE_BUILD=true; shift ;;
        --tag)
            if [[ -n "$2" && "$2" != -* ]]; then SPECIFIED_SERVER_TAG="$2"; shift 2;
            else echo "Error: Argument for --tag is missing" >&2; display_help; exit 1; fi ;;
        --detached)
            if [[ "$2" == "true" ]]; then FORCE_SERVER_DETACHED="yes";
            elif [[ "$2" == "false" ]]; then FORCE_SERVER_DETACHED="no";
            else echo "Error: Invalid value for --detached. Use 'true' or 'false'." >&2; display_help; exit 1; fi
            shift 2 ;;
        --apk) DO_APK_PREP=true; shift ;;
        --apk-only) DO_APK_PREP=true; APK_ONLY_MODE=true; shift ;;
        *) echo "Unknown option: $1" >&2; display_help; exit 1 ;;
    esac
done

# --- Script Body ---
echo "================================================================";
echo "== GestureVision Production Deployment/APK Prep Helper =="
echo "================================================================"; echo

if [ ! -f "$EXAMPLE_ENV_FILE" ]; then echo "Error: '$EXAMPLE_ENV_FILE' not found." >&2; exit 1; fi
if [ ! -f "$ENV_FILE" ]; then echo "Info: '$ENV_FILE' not found. Copying from '$EXAMPLE_ENV_FILE'."; cp "$EXAMPLE_ENV_FILE" "$ENV_FILE"; fi

if $DO_APK_PREP; then
    # FIX: Point to the correct file location inside the config/ directory
    if [ ! -f "config/.env.apk" ]; then echo "Error: 'config/.env.apk' not found. This is required for APK asset build." >&2; exit 1; fi
    if ! command -v npm &> /dev/null; then echo "Error: npm is not installed. Required for 'npm run build:apk'." >&2; exit 1; fi
    if ! command -v npx &> /dev/null; then echo "Error: npx is not installed. Required for Capacitor commands." >&2; exit 1; fi
fi

if ! $APK_ONLY_MODE; then
    if [ ! -f "$DOCKER_COMPOSE_FILE" ]; then echo "Error: '$DOCKER_COMPOSE_FILE' not found for server deployment." >&2; exit 1; fi
    # FIX: Point to the correct file location inside the config/ directory
    if [ ! -f "config/config.prod.json" ]; then echo "Warning: 'config/config.prod.json' not found. Server deployment may lack key settings."; fi
fi

declare -A current_env_values; APP_VERSION=$(node -p "require('./package.json').version" 2>/dev/null || echo "unknown"); export APP_VERSION
ALL_KEYS_TO_LOAD=( "PROD_IMAGE_NAME" "${!ENV_VARS_TO_REVIEW[@]}" ); mapfile -t UNIQUE_KEYS < <(printf "%s\n" "${ALL_KEYS_TO_LOAD[@]}" | sort -u)
for key in "${UNIQUE_KEYS[@]}"; do current_env_values["$key"]=$(get_env_var "$key" "$ENV_FILE"); done
SUGGESTED_SERVER_TAG="gesturevision:${APP_VERSION}";
DEFAULT_SERVER_IMAGE_PROMPT="${SPECIFIED_SERVER_TAG:-${current_env_values["PROD_IMAGE_NAME"]:-$SUGGESTED_SERVER_TAG}}"
if [ -n "$SPECIFIED_SERVER_TAG" ]; then current_env_values["PROD_IMAGE_NAME"]="$SPECIFIED_SERVER_TAG"; fi

DO_SERVER_DEPLOY="yes"
if $APK_ONLY_MODE; then
    DO_SERVER_DEPLOY="no"
    echo "[INFO] --apk-only flag specified. Skipping all server deployment steps."
elif $DO_APK_PREP && [[ "$FORCE_SERVER_BUILD" != "yes" && -z "$SPECIFIED_SERVER_TAG" && -z "${current_env_values["PROD_IMAGE_NAME"]}" ]] ; then
    if $BYPASS_SERVER_INTERACTIVE; then
      echo "[INFO] --apk flag present, server build not forced, and no server image specified. Skipping server deployment with -y."
      DO_SERVER_DEPLOY="no"
    elif [ "$FORCE_SERVER_BUILD" == "ask" ]; then
        read -r -p "The --apk flag is set. Do you also want to proceed with server deployment/configuration? (Y/n) [Y]: " yn_server_deploy
        yn_server_deploy=${yn_server_deploy:-Y}
        if [[ "$yn_server_deploy" =~ ^[Nn]$ ]]; then
            DO_SERVER_DEPLOY="no"
            echo "[INFO] Skipping server deployment steps as per user choice."
        fi
    fi
fi

if [ "$DO_SERVER_DEPLOY" == "yes" ]; then
    echo; echo "--- Server Deployment Configuration ---"
    DO_SERVER_BUILD_ACTION="$FORCE_SERVER_BUILD"
    CHOSEN_SERVER_IMAGE_TAG="${current_env_values["PROD_IMAGE_NAME"]}"
    SERVER_DETACHED_FLAG_CHOICE="$FORCE_SERVER_DETACHED"

    declare -A updated_env_values_server
    for key in "${!current_env_values[@]}"; do updated_env_values_server["$key"]="${current_env_values[$key]}"; done
    CONFIG_SERVER_CHANGED=false; SAVE_SERVER_NEEDED=false

    if $BYPASS_SERVER_INTERACTIVE; then
        echo "Bypassing interactive server configuration (-y specified)."
        if [[ "$FORCE_SERVER_BUILD" == "ask" ]]; then DO_SERVER_BUILD_ACTION="yes"; fi
        CHOSEN_SERVER_IMAGE_TAG=${SPECIFIED_SERVER_TAG:-${updated_env_values_server["PROD_IMAGE_NAME"]:-$SUGGESTED_SERVER_TAG}}
        updated_env_values_server["PROD_IMAGE_NAME"]="$CHOSEN_SERVER_IMAGE_TAG"
        if [[ "$CHOSEN_SERVER_IMAGE_TAG" != "${current_env_values["PROD_IMAGE_NAME"]}" ]]; then SAVE_SERVER_NEEDED=true; fi
        # Ensure essential internal ports have defaults if not set in bypass mode
        if [[ -z "${updated_env_values_server[MTX_PROD_WEBRTC_PORT_INTERNAL]}" ]]; then updated_env_values_server[MTX_PROD_WEBRTC_PORT_INTERNAL]="8888"; SAVE_SERVER_NEEDED=true; fi
        if [[ -z "${updated_env_values_server[MTX_PROD_ICE_UDP_PORT_INTERNAL]}" ]]; then updated_env_values_server[MTX_PROD_ICE_UDP_PORT_INTERNAL]="8189"; SAVE_SERVER_NEEDED=true; fi
        if [[ -z "${updated_env_values_server[MTX_API]}" ]]; then updated_env_values_server[MTX_API]="yes"; SAVE_SERVER_NEEDED=true; fi
        if [[ -z "${updated_env_values_server[MTX_APIADDRESS_INTERNAL]}" ]]; then updated_env_values_server[MTX_APIADDRESS_INTERNAL]="0.0.0.0:9997"; SAVE_SERVER_NEEDED=true; fi
        if [[ -z "${updated_env_values_server[BACKEND_API_PORT_INTERNAL]}" ]]; then updated_env_values_server[BACKEND_API_PORT_INTERNAL]="9001"; SAVE_SERVER_NEEDED=true; fi
        if [[ "$FORCE_SERVER_DETACHED" == "ask" ]]; then SERVER_DETACHED_FLAG_CHOICE="yes"; fi
    else # Interactive mode for server config
        echo; echo "Step 1: Server Image Strategy"
        if [ "$DO_SERVER_BUILD_ACTION" == "ask" ]; then while true; do read -r -p "Build server image from source? (Y/n/s=skip) [Y]: " yn_build; yn_build=${yn_build:-Y}; case $yn_build in [Yy]* ) DO_SERVER_BUILD_ACTION="yes"; break;; [NnSs]* ) DO_SERVER_BUILD_ACTION="no"; break;; * ) echo "Ans y/n/s.";; esac; done; fi
        echo; echo "Step 2: Server Image Name/Tag"
        if [ -z "$CHOSEN_SERVER_IMAGE_TAG" ] && [ -z "$SPECIFIED_SERVER_TAG" ]; then
            PROMPT_TEXT_S="Enter server image tag "; CURRENT_ENV_TAG_VALUE_S="${updated_env_values_server["PROD_IMAGE_NAME"]}"; TRANSLATED_TAG_VALUE_S=$(echo "$CURRENT_ENV_TAG_VALUE_S" | sed "s/\${APP_VERSION}/$APP_VERSION/g")
            TRANSLATED_TAG_DISPLAY_S=$([[ "$TRANSLATED_TAG_VALUE_S" != "$CURRENT_ENV_TAG_VALUE_S" ]] && echo " (evaluates to '${TRANSLATED_TAG_VALUE_S}')" || echo "")
            if [ "$DO_SERVER_BUILD_ACTION" == "yes" ]; then PROMPT_TEXT_S+="to BUILD [Current: '${CURRENT_ENV_TAG_VALUE_S}'${TRANSLATED_TAG_DISPLAY_S} | Suggested: '${SUGGESTED_SERVER_TAG}']: ";
            else PROMPT_TEXT_S+="of EXISTING image to RUN [Current: '${CURRENT_ENV_TAG_VALUE_S}'${TRANSLATED_TAG_DISPLAY_S}]: "; fi
            read -r -p "$PROMPT_TEXT_S" tag_input_s; CHOSEN_SERVER_IMAGE_TAG=${tag_input_s:-$DEFAULT_SERVER_IMAGE_PROMPT}
            if [[ "$DO_SERVER_BUILD_ACTION" == "no" && -z "$CHOSEN_SERVER_IMAGE_TAG" ]]; then echo "Error: Server image name required." >&2; exit 1; fi
        elif [ -n "$SPECIFIED_SERVER_TAG" ]; then CHOSEN_SERVER_IMAGE_TAG="$SPECIFIED_SERVER_TAG"; fi
        echo "Will use server image tag: $CHOSEN_SERVER_IMAGE_TAG"; if [[ "${updated_env_values_server[PROD_IMAGE_NAME]}" != "$CHOSEN_SERVER_IMAGE_TAG" ]]; then updated_env_values_server["PROD_IMAGE_NAME"]="$CHOSEN_SERVER_IMAGE_TAG"; SAVE_SERVER_NEEDED=true; fi

        echo; echo "Step 3: Review/Configure Server Environment ('$ENV_FILE')"
        while true; do echo; echo "Variable Descriptions:"; declare -a req_keys_hint_s=(); declare -a opt_keys_hint_s=(); mapfile -t sorted_keys_s < <(printf "%s\n" "${!ENV_VARS_TO_REVIEW[@]}" | sort);
            declare -A num_to_key_map_s; item_num_s=1
            for key_s in "${sorted_keys_s[@]}"; do if [[ "${ENV_VARS_TO_REVIEW[$key_s]}" =~ ^Req: ]]; then req_keys_hint_s+=("$key_s"); else opt_keys_hint_s+=("$key_s"); fi; done
            echo "** Required Configuration **"; for key_s in "${req_keys_hint_s[@]}"; do [[ "${ENV_VARS_TO_REVIEW[$key_s]}" =~ ^Req:(.*) ]]; printf "[%2d] %-35s : %s\n" "$item_num_s" "$key_s" "${BASH_REMATCH[1]}"; num_to_key_map_s[$item_num_s]="$key_s"; ((item_num_s++)); done
            echo; echo "** Optional Configuration **"; for key_s in "${opt_keys_hint_s[@]}"; do [[ "${ENV_VARS_TO_REVIEW[$key_s]}" =~ ^Opt:(.*) ]]; printf "[%2d] %-35s : %s\n" "$item_num_s" "$key_s" "${BASH_REMATCH[1]}"; num_to_key_map_s[$item_num_s]="$key_s"; ((item_num_s++)); done; max_num_s=$((item_num_s - 1))
            echo "---------------------------------------------------------------------"; echo "Current Values:"; printf "%-4s %-35s | %-s\n" "Num" "Variable Name" "Current Value"; echo "---- ------------------------------------|----------------------------------------------"
            item_num_val_s=1; echo "** Required Configuration **"; for key_s in "${req_keys_hint_s[@]}"; do display_val_s="${updated_env_values_server["$key_s"]}"; if [[ "$key_s" == "VITE_PROD_HA_DEFAULT_TOKEN" && -n "$display_val_s" ]]; then display_val_s="********"; fi; printf "%-4s %-35s | %-s\n" "[$item_num_val_s]" "$key_s" "$display_val_s"; ((item_num_val_s++)); done
            echo; echo "** Optional Configuration **"; for key_s in "${opt_keys_hint_s[@]}"; do display_val_s="${updated_env_values_server["$key_s"]}"; if [[ "$key_s" == "VITE_PROD_HA_DEFAULT_TOKEN" && -n "$display_val_s" ]]; then display_val_s="********"; fi; printf "%-4s %-35s | %-s\n" "[$item_num_val_s]" "$key_s" "$display_val_s"; ((item_num_val_s++)); done
            echo; echo "** Deployment Settings **"; printf "%-4s %-35s | %s\n" "" "PROD_IMAGE_NAME" "${updated_env_values_server["PROD_IMAGE_NAME"]}"; echo "-------------------------------------|----------------------------------------------"
            read -r -p "Enter number of server variable to change (1-$max_num_s), or 0 to continue: " user_choice_s
            if [[ "$user_choice_s" == "0" ]]; then break; fi
            if [[ "$user_choice_s" =~ ^[1-9][0-9]*$ && "$user_choice_s" -le "$max_num_s" ]]; then
                 var_to_change_s="${num_to_key_map_s[$user_choice_s]}"; if [[ -z "$var_to_change_s" ]]; then echo "Error: Invalid selection."; continue; fi
                 read -r -p "Enter NEW value for ${var_to_change_s} (Current: '${updated_env_values_server["$var_to_change_s"]:-<empty>}'): " new_val_s
                 if [ -n "$new_val_s" ] || [[ -n "${updated_env_values_server["$var_to_change_s"]}" ]]; then if [[ "${updated_env_values_server["$var_to_change_s"]}" != "$new_val_s" ]]; then updated_env_values_server["$var_to_change_s"]="$new_val_s"; CONFIG_SERVER_CHANGED=true; SAVE_SERVER_NEEDED=true; echo "'$var_to_change_s' updated."; else echo "Value unchanged."; fi
                 else echo "Value kept as '${updated_env_values_server["$var_to_change_s"]}'."; fi; echo
            else echo "Invalid input."; fi
        done
        if $CONFIG_SERVER_CHANGED; then echo; echo "Proposed server configuration changes:"; for key_s in "${!updated_env_values_server[@]}"; do if [[ "${current_env_values[$key_s]}" != "${updated_env_values_server[$key_s]}" && (-v ENV_VARS_TO_REVIEW["$key_s"] || "$key_s" == "PROD_IMAGE_NAME") ]]; then printf "* %-35s : '%s'\n" "$key_s" "${updated_env_values_server[$key_s]}"; fi; done; read -r -p "Confirm (Y/n): " yn_save_confirm_s; if [[ "$yn_save_confirm_s" =~ ^[Nn]$ ]]; then echo "Aborting."; exit 1; fi
        elif $SAVE_SERVER_NEEDED; then read -r -p "Image tag changed, proceed? (Y/n): " yn_save_tag_s; if [[ "$yn_save_tag_s" =~ ^[Nn]$ ]]; then echo "Aborting."; exit 1; fi; fi

        echo; echo "Step 4: Server Run Options"; if [ "$SERVER_DETACHED_FLAG_CHOICE" == "ask" ]; then read -r -p "Run server detached? (Y/n) [Y]: " yn_detached_s; yn_detached_s=${yn_detached_s:-Y}; if [[ "$yn_detached_s" =~ ^[Yy]$ ]]; then SERVER_DETACHED_FLAG_CHOICE="yes"; else SERVER_DETACHED_FLAG_CHOICE="no"; fi; fi
    fi

    # Ensure defaults for key internal variables if not set, and mark for save if changed
    if [[ -z "${updated_env_values_server[MTX_PROD_WEBRTC_PORT_INTERNAL]}" ]]; then updated_env_values_server[MTX_PROD_WEBRTC_PORT_INTERNAL]="8888"; SAVE_SERVER_NEEDED=true; fi
    if [[ -z "${updated_env_values_server[MTX_PROD_ICE_UDP_PORT_INTERNAL]}" ]]; then updated_env_values_server[MTX_PROD_ICE_UDP_PORT_INTERNAL]="8189"; SAVE_SERVER_NEEDED=true; fi
    if [[ -z "${updated_env_values_server[MTX_API]}" ]]; then updated_env_values_server[MTX_API]="yes"; SAVE_SERVER_NEEDED=true; fi
    if [[ -z "${updated_env_values_server[MTX_APIADDRESS_INTERNAL]}" ]]; then updated_env_values_server[MTX_APIADDRESS_INTERNAL]="0.0.0.0:9997"; SAVE_SERVER_NEEDED=true; fi # Use 0.0.0.0
    if [[ -z "${updated_env_values_server[BACKEND_API_PORT_INTERNAL]}" ]]; then updated_env_values_server[BACKEND_API_PORT_INTERNAL]="9001"; SAVE_SERVER_NEEDED=true; fi

    if $SAVE_SERVER_NEEDED; then save_config_to_env "$ENV_FILE" updated_env_values_server "$EXAMPLE_ENV_FILE"; fi

    FINAL_SERVER_IMAGE_TAG="${updated_env_values_server[PROD_IMAGE_NAME]}"
    FINAL_SERVER_DETACHED_FLAG=$([[ "$SERVER_DETACHED_FLAG_CHOICE" == "yes" ]] && echo "-d" || echo "")

    echo; echo "======================================================"; echo "=== Server Deployment Actions ==="; echo "======================================================"
    echo "Server Image Strategy: ${DO_SERVER_BUILD_ACTION}"; echo "Server Image: ${FINAL_SERVER_IMAGE_TAG}"; echo "Server Detached: '${FINAL_SERVER_DETACHED_FLAG}'"; echo
    echo "[ACTION] Stopping server instance and removing volumes..."
    $DOCKER_COMPOSE_CMD -p "$PROJECT_NAME" --env-file "$ENV_FILE" -f "$DOCKER_COMPOSE_FILE" down -v || echo "[INFO] No previous instance or error stopping."
    if [ "$DO_SERVER_BUILD_ACTION" == "yes" ]; then
        echo "[ACTION] Building Production Server Image (tag: $FINAL_SERVER_IMAGE_TAG)..."
        BUILD_ARGS_PROD=""
        if $NO_CACHE_BUILD; then BUILD_ARGS_PROD="--no-cache"; echo "Building with --no-cache flag."; fi
        # Pass Vite build-time args to Docker build
        VITE_BUILD_ARGS="--build-arg VITE_PROD_WHEP_BASE_URL=\"${updated_env_values_server[APP_EXTERNAL_URL]}\" \
                         --build-arg VITE_PROD_HA_DEFAULT_URL=\"${updated_env_values_server[VITE_PROD_HA_DEFAULT_URL]}\" \
                         --build-arg VITE_PROD_HA_DEFAULT_TOKEN=\"${updated_env_values_server[VITE_PROD_HA_DEFAULT_TOKEN]}\""

        # shellcheck disable=SC2086
        if $DOCKER_COMPOSE_CMD -p "$PROJECT_NAME" -f "$DOCKER_COMPOSE_FILE" --env-file "$ENV_FILE" build $VITE_BUILD_ARGS $BUILD_ARGS_PROD; then
             echo "[SUCCESS] Server Build complete."; echo "[ACTION] Pruning old images..."; docker image prune -f --filter "label=project=gesturevision";
        else echo "!! DOCKER SERVER BUILD FAILED !!" >&2; exit 1; fi
    elif [ "$DO_SERVER_BUILD_ACTION" == "no" ]; then echo "[INFO] Skipping server image build.";
    fi

    if [ "$DO_SERVER_BUILD_ACTION" != "skip" ]; then
        echo "[ACTION] Starting Production Server Container..."
        # shellcheck disable=SC2086
        $DOCKER_COMPOSE_CMD -p "$PROJECT_NAME" -f "$DOCKER_COMPOSE_FILE" --env-file "$ENV_FILE" up $FINAL_SERVER_DETACHED_FLAG
        START_EXIT_CODE=$?; if [ $START_EXIT_CODE -ne 0 ]; then if [ $START_EXIT_CODE -eq 130 ]; then echo "[INFO] Server Docker Compose interrupted."; else echo "!! SERVER DOCKER COMPOSE UP FAILED (Code: $START_EXIT_CODE) !!" >&2; fi; exit $START_EXIT_CODE; fi
        echo "======================================================"; echo "GestureVision Server Deployment Complete!"; echo "Image: $FINAL_SERVER_IMAGE_TAG"; if [ "$FINAL_SERVER_DETACHED_FLAG" == "-d" ]; then echo "Logs: '$DOCKER_COMPOSE_CMD -p \"$PROJECT_NAME\" logs -f gesturevision-prod'"; fi; echo "URL: $(get_env_var APP_EXTERNAL_URL "$ENV_FILE")"; echo "======================================================";
    else
        echo "[INFO] Server deployment steps fully skipped."
    fi
fi

if $DO_APK_PREP; then
    echo
    echo "======================================================"
    echo "=== APK Asset Preparation ==="
    echo "======================================================"
    if [ -f "./tools/update_apk.sh" ]; then
        chmod +x ./tools/update_apk.sh
        echo "[ACTION] Executing ./tools/update_apk.sh script..."
        # Pass --yes to update_apk.sh if bypass was set for server deployment
        if $BYPASS_SERVER_INTERACTIVE; then ./tools/update_apk.sh -y; else ./tools/update_apk.sh; fi
        if [ $? -ne 0 ]; then echo "[ERROR] ./tools/update_apk.sh failed." >&2; exit 1; fi
    else echo "[ERROR] ./tools/update_apk.sh script not found." >&2; exit 1; fi
    echo "======================================================"
    echo "APK Asset Preparation Complete!"
    echo "======================================================"
fi

exit 0