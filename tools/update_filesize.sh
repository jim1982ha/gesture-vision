#!/bin/bash
# FILE: tools/update_filesize.sh

# Navigate to the project root (parent directory of this script)
cd "$(dirname "$0")/.." || exit 1

# Script to find JavaScript (.js), TypeScript (.ts), and CSS (.css) files recursively
# from a specified directory (or defaults to ./packages/ if it exists, else current directory),
# count their lines, and display them sorted by line count (descending).

# --- Configuration ---
DEFAULT_DIR="./packages" # Prioritize scanning the packages directory
TARGET_DIR="$DEFAULT_DIR"

# --- Helper Function: Display Help ---
display_help() {
    local script_name
    script_name=$(basename "$0")
    echo "Usage: ./tools/${script_name} [options]"
    echo
    echo "Scans for source code files (.js, .ts, .css) and displays them sorted by line count."
    echo
    echo "Options:"
    echo "  -h, --help               Display this help message and exit."
    echo "  -d, --directory <path>   Specify the directory to scan."
    echo "                           Defaults to './packages' if it exists, otherwise '.'."
    echo
}

# --- Argument Parsing ---
# Loop through command-line arguments provided to the script
while [[ "$#" -gt 0 ]]; do
    case $1 in
        -h|--help)
            display_help
            exit 0
            ;;
        -d|--directory)
            # Ensure an argument value (the path) is provided after the flag
            # and it doesn't start with '-' (indicating another flag)
            if [[ -n "$2" && "$2" != -* ]]; then
                TARGET_DIR="$2" # Set the target directory
                shift # Consume the flag's value ($2)
            else
                # Print error to standard error and exit if value is missing
                echo "Error: Argument for $1 is missing" >&2
                exit 1
            fi
            ;;
        # Handle any unknown options passed to the script
        *)
            echo "Unknown parameter passed: $1" >&2
            display_help # Show help on unknown parameter
            exit 1
            ;;
    esac
    # Move to the next argument or flag
    shift
done

# --- Directory Validation ---
# If the default DEFAULT_DIR doesn't exist, fall back to current directory for scanning.
if [[ "$TARGET_DIR" == "$DEFAULT_DIR" && ! -d "$DEFAULT_DIR" ]]; then
    echo "Warning: Default directory '$DEFAULT_DIR' not found. Scanning current directory '.' instead."
    TARGET_DIR="."
fi

# Check if the final TARGET_DIR exists and is actually a directory
if [ ! -d "$TARGET_DIR" ]; then
    echo "Error: Directory '$TARGET_DIR' not found or is not a directory." >&2
    exit 1 # Exit with an error status
fi

clear

# --- User Feedback ---
# Inform the user which directory is being scanned
echo "Scanning for .css, .js and .ts files in: $TARGET_DIR"
echo "--------------------------------------------------"

# --- Main Logic ---
# 1. Find files:
#    - Start search in TARGET_DIR
#    - Exclude node_modules, dist, dist-backend, and any .git directories from the search path
#    - Look only for files (-type f)
#    - Match names ending in .js OR .ts OR .css
#    - Print null-separated paths (-print0) for safety
find "$TARGET_DIR" \
    -type d \( -name "node_modules" -o -name "dist" -o -name "dist-*" -o -name ".git" -o -name "android" -o -name "ios" -o -name "coverage" \) -prune \
    -o -type f \( -name "*.js" -o -name "*.ts" -o -name "*.css" \) -print0 | \
# 2. Count lines:
#    - Read null-separated paths (-0)
#    - Run wc -l on the paths to count lines
#    - Output format: "   count path"
xargs -0 wc -l 2>/dev/null | \
# 3. Filter out total:
#    - Remove the summary "total" line generated by wc -l when given multiple files
grep -v ' total$' | \
# 4. Sort results:
#    - Sort numerically (-n) based on the first field (the count)
#    - Sort in reverse order (-r) to put the largest files first
sort -nr | \
# 5. Format output:
#    - Process each sorted line (e.g., "   120 ./src/main.js")
#    - Print the path ($2) followed by " => " and the count ($1)
#    - %s for the path string, %d for the integer count
awk '{ printf "%s => %d\n", $2, $1 }'

# End of script
echo "--------------------------------------------------"
echo "Scan complete."